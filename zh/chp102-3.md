---
layout: post
title: 源码开放学ARM - Linux 内核模块 - 模块加载和卸载
---

## 模块加载和卸载

### 模块的操作命令

#### 插入模块 insmod
模块编译后需要通过特定的工具加载，这个工具就是insmod.
与其相关的命令还有几个，我们来看看详细的描述：

	insmod
	bash# insmod hello.ko

	vi include/generated/utsrelease.h 
	#define UTS_RELEASE "2.6.35.7-FriendlyARM"
	
#### 查看模块 lsmod
查看当前有多少模块。
	lsmod

	$ lsmod	
	Module                    Size  Used by
	hello                     2304   0
	Used by表明有没有用户使用这个模块。如果使用了就不能rmmod它。
	
	cat /proc/modules 查看已经加载的模块信息。

#### 删除模块 rmmod
删除已经有的模块。
	
	rmmod
	$ rmmod hello

#### 查看模块 modinfo 
	$ modinfo hello.ko
	modinfo 命令可以获得模块作者，说明，参数和许可协议等信息。
	
#### modprobe 工具
	$ modprobe helllo.ko
	modprobe, 如同 insmod, 加载一个模块到内核. 
	它的不同在于它会查看要加载的模块, 看是否它引用了当前内核没有定义的符号. 
	如果发现有, modprobe 在定义相关符号的当前模块搜索路径中寻找其他模块. 
	当 modprobe 找到这些模块( 要加载模块需要的 ), 它也把它们加载到内核. 
	如果你在这种情况下使用 insmod 代替, 命令会失败, 在系统日志文件中留下一条 " unresolved symbols "消息.

### 许可协议
内核认识的特定许可有, "GPL"( 适用 GNU 通用公共许可的任何版本 ), "GPL v2"( 只适用 GPL 版本 2 ), "GPL and additional rights", "Dual BSD/GPL", "Dual MPL/GPL", 和 "Proprietary". 除非你的模块明确标识是在内核认识的一个自由许可下, 否则就假定它是私有的, 内核在模块加载时被"弄污浊"了. 象我们在第 1 章"许可条款"中提到的, 内核开发者不会热心帮助在加载了私有模块后遇到问题的用户.

可以在模块中包含的其他描述性定义有 

	MODULE_AUTHOR ( 声明谁编写了模块 ), 
	MODULE_DESCRIPION( 一个人可读的关于模块做什么的声明 ), 
	MODULE_VERSION ( 一个代码修订版本号; 看 <linux/module.h> 的注释以便知道创建版本字串使用的惯例), 
	MODULE_ALIAS ( 模块为人所知的另一个名子 ), 
	MODULE_DEVICE_TABLE ( 来告知用户空间, 模块支持那些设备 ). 

### 命名空间和符号导出
	cat /proc/kallsyms 查看内核的符号表。	

	EXPORT_SYMBOL(symbol_name)

### 给模块传参数
Linux2.6允许用户insmod的时候往内核模块里面传递参数，它主要使用module_param宏定义来实现这一功能。

module_param的定义可以在include/linux/moduleparam.h文件里面查看到，它的原型为：

	module_param(name, type, perm);

	name是在模块中定义的变量名称，type是变量的类型，perm是权限掩码，一般填0就可以。

	static int howmany = 1;
	module_param(howmany, int, 0);



[上一节](chp102-2.html)  |  [目录索引](../index.html)  |  [下一节](chp102-4.html)
