---
layout: post
title: 源码开放学ARM - Linux 驱动的并发控制 - 互斥体
---

## 互斥体
互斥体完成的功能和信号量很相似。

### 互斥体的操作
	1、定义并初时化互斥体
	struct mutex my_mutex;
	mutex_init(&my_mutex);

	2、获取互斥体
	void fastcall mutex_lock(struct mutex *lock);
	int fastcall mutex_lock_interruptiable(struct mutex *lock);
	int fastcall mytex_trylock(struct mutex *lock);

	3、释放互斥体
	void fastcall mutex_unlock(struct mutex	*lock);

	4、互斥体使用模板
	struct mutex my_mutex;
	mutex_init(&my_mutex);
	mutex_lock(&my_mutex);
	……
	mutex_unlock(&my_mutex);

### 总结
自旋锁 VS 信号量

1、信号量是进程级的，用于多个进程之间对资源的互斥，虽然也是在内核中，但是该内核执行路径是以进程的身份。
如果竞争失败，会发生进程上下文切换，当前进程进入休眠状态，CPU运行其他进程。
因为进程上下文切换开销很大，所以只有当进程占用资源时间较长时，用信号量才是较好的选择。

2、自旋锁得不到锁时就会在原处自旋一直到获得锁，它节省了上下文切换的时间，所以一般用于要保护的临界区访问时间比较短的时候，否则会降低系统效率。

3、自旋锁和信号量选用的原则：

A、临界区执行时间比较小时，采用自旋锁，否则使用信号量。

B、信号量所保护的临界区包含可能引起阻塞的代码，而自旋锁要绝对避免在临界区中使用该类型的代码。

C、信号量存在于进程上下文，因此如果被保护的共享资源要在中断或软中断情况下使用，则应该选用自旋锁，
	如果一定要使用信号量，则只能通过 down_trylock()的方式进行，不能获取就立即返回，避免阻塞。

[上一节](chp105-5.html)  |  [目录索引](../index.html)  |  [下一节](chp106-1.html)
