---
layout: post
title: 源码开放学ARM - Linux 字符设备驱动 - 文件操作和file结构
---

## 文件操作和file结构

### struct file_operations  

	struct file_operations {
		struct module *owner;
		loff_t (*llseek) (struct file *, loff_t, int);
		ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
		ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
		ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
		ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
		int (*readdir) (struct file *, void *, filldir_t);
		unsigned int (*poll) (struct file *, struct poll_table_struct *);
		long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
		long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
		int (*mmap) (struct file *, struct vm_area_struct *);
		int (*open) (struct inode *, struct file *);
		int (*flush) (struct file *, fl_owner_t id);
		int (*release) (struct inode *, struct file *);
		int (*fsync) (struct file *, int datasync);
		int (*aio_fsync) (struct kiocb *, int datasync);
		int (*fasync) (int, struct file *, int);
		int (*lock) (struct file *, int, struct file_lock *);
		ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
		unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
		int (*check_flags)(int);
		int (*flock) (struct file *, int, struct file_lock *);
		ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
		ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
		int (*setlease)(struct file *, long, struct file_lock **);
	};


这个结构, 定义在 linux/fs.h, 是一个函数指针的集合. 每个打开文件(内部用一个 file 结构来代表, 稍后我们会查看)与它自身的函数集合相关连( 通过包含一个称为 f_op 的成员, 它指向一个 file_operations 结构). 这些操作大部分负责实现系统调用, 因此, 命名为 open, read, 等等. 我们可以认为文件是一个"对象"并且其上的函数操作称为它的"方法", 使用面向对象编程的术语来表示一个对象声明的用来操作对象的动作.

### 基本元素

file_operations的主要域：

	struct module *owner：指向模块自身。
	open：打开设备。
	release：关闭设备。
	read：从设备上读数据。
	write：向设备上写数据。
	ioctl：操作设备函数。
	mmap：映射设备空间到进程的地址空间。

### 接口含义

	struct module *owner 
		
第一个 file_operations 成员根本不是一个操作; 它是一个指向拥有这个结构的模块的指针. 这个成员用来在它的操作还在被使用时阻止模块被卸载. 几乎所有时间中, 它被简单初始化为 THIS_MODULE, 一个在 linux/module.h 中定义的宏.	

	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); 
	
用来从设备中获取数据. 在这个位置的一个空指针导致 read 系统调用以 -EINVAL("Invalid argument") 失败. 一个非负返回值代表了成功读取的字节数( 返回值是一个 "signed size" 类型, 常常是目标平台本地的整数类型).

	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); 
	
发送数据给设备. 如果 NULL, -EINVAL 返回给调用 write 系统调用的程序. 如果非负, 返回值代表成功写的字节数.

	int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long); 

ioctl 系统调用提供了发出设备特定命令的方法(例如格式化软盘的一个磁道, 这不是读也不是写). 另外, 几个 ioctl 命令被内核识别而不必引用 fops 表. 如果设备不提供 ioctl 方法, 对于任何未事先定义的请求(-ENOTTY, "设备无这样的 ioctl"), 系统调用返回一个错误. 

	int (*mmap) (struct file *, struct vm_area_struct *); 

mmap 用来请求将设备内存映射到进程的地址空间. 如果这个方法是 NULL, mmap 系统调用返回 -ENODEV.

	int (*open) (struct inode *, struct file *); 

尽管这常常是对设备文件进行的第一个操作, 不要求驱动声明一个对应的方法. 如果这个项是 NULL, 设备打开一直成功, 但是你的驱动不会得到通知.

	int (*release) (struct inode *, struct file *); 
	
在文件结构被释放时引用这个操作. 如同 open, release 可以为 NULL.

### struct inode_operations

	struct inode_operations {
		int (*create) (struct inode *,struct dentry *,int, struct nameidata *);
		struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
		int (*link) (struct dentry *,struct inode *,struct dentry *);
		int (*unlink) (struct inode *,struct dentry *);
		int (*symlink) (struct inode *,struct dentry *,const char *);
		int (*mkdir) (struct inode *,struct dentry *,int);
		int (*rmdir) (struct inode *,struct dentry *);
		int (*mknod) (struct inode *,struct dentry *,int,dev_t);
		int (*rename) (struct inode *, struct dentry *,
				struct inode *, struct dentry *);
		int (*readlink) (struct dentry *, char __user *,int);
		void * (*follow_link) (struct dentry *, struct nameidata *);
		void (*put_link) (struct dentry *, struct nameidata *, void *);
		void (*truncate) (struct inode *);
		int (*permission) (struct inode *, int);
		int (*check_acl)(struct inode *, int);
		int (*setattr) (struct dentry *, struct iattr *);
		int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
		int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
		ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
		ssize_t (*listxattr) (struct dentry *, char *, size_t);
		int (*removexattr) (struct dentry *, const char *);
		void (*truncate_range)(struct inode *, loff_t, loff_t);
		long (*fallocate)(struct inode *inode, int mode, loff_t offset,
				  loff_t len);
		int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
			      u64 len);
	};


### 用户空间和kernel空间的数据互传

模块在很多时候需要和用户程序交互，其中包括数据传输。在模块里做传输的时候使用memcpy往往会出错。

请看例子：

	在用户空间里定义：
	char user_buffer[100];

	在内核模块里定义：
	char kernel_buffer[100];

	使用 memcpy(kernel_buffer,user_buffer,100);
	往往不能成功；原因在于用户空间的user_buffer，有可能是缺页状态。这时候kernel会出现异常。

	我们需要使用更安全的函数 copy_to_user, copy_from_user。 它们的定义在 arch/arm/asm/uaccess.h 文件中。

	copy_to_user(user_buffer,kernel_buffer,100);

	copy_from_user(kernel_buffer,user_buffer,100);

	这里还有一个函数：
	put_user(k,u),get_user(k,u);	它们适合于每次访问char,int等单个数据类型；



[上一节](chp103-2.html)  |  [目录索引](../index.html)  |  [下一节](chp103-4.html)
