---
layout: post
title: 源码开放学ARM - Linux 字符设备驱动 - 主设备号和次设备号
---

## 主设备号和次设备号

### 主次设备号
字符设备通过文件系统中的名字来存取. 那些名子称为文件系统的特殊文件, 或者设备文件, 或者文件系统的简单结点; 惯例上它们位于 /dev 目录. 字符驱动的特殊文件由使用 ls -l 的输出的第一列的"c"标识. 块设备也出现在 /dev 中, 但是它们由"b"标识. 本章集中在字符设备, 但是下面的很多信息也适用于块设备.

如果你发出 ls -l 命令, 你会看到在设备文件项中有 2 个数(由一个逗号分隔)在最后修改日期前面, 这里通常是文件长度出现的地方. 这些数字是给特殊设备的主次设备编号. 下面的列表显示了一个典型系统上出现的几个设备. 它们的主编号是 1, 4, 7, 和 10, 而次编号是 1, 3, 5, 64, 65, 和 129.

	crw-rw-rw- 1 root  root  1,  3 Apr 11  2002 null 
	crw------- 1 root  root  10, 1 Apr 11  2002 psaux 
	crw------- 1 root  root  4,  1 Oct 28 03:04 tty1 
	crw-rw-rw- 1 root  tty   4, 64 Apr 11  2002 ttys0 
	crw-rw---- 1 root  uucp  4, 65 Apr 11  2002 ttyS1 
	crw--w---- 1 vcsa  tty   7,  1 Apr 11  2002 vcs1 
	crw--w---- 1 vcsa  tty   7,129 Apr 11  2002 vcsa1 
	crw-rw-rw- 1 root  root  1,  5 Apr 11  2002 zero  
 
传统上, 主编号标识设备相连的驱动. 例如, /dev/null 和 /dev/zero 都由驱动 1 来管理, 而虚拟控制台和串口终端都由驱动 4 管理; 同样, vcs1 和 vcsa1 设备都由驱动 7 管理. 现代 Linux 内核允许多个驱动共享主编号, 但是你看到的大部分设备仍然按照一个主编号一个驱动的原则来组织.

次编号被内核用来决定引用哪个设备. 依据你的驱动是如何编写的(如同我们下面见到的), 你可以从内核得到一个你的设备的直接指针, 或者可以自己使用次编号作为本地设备数组的索引. 不论哪个方法, 内核自己几乎不知道次编号的任何事情, 除了它们指向你的驱动实现的设备.

### 注册设备

通用方法

注册一个字符设备的经典方法是使用:

	int register_chrdev(unsigned int major, const char *name, struct file_operations *fops);
	
这里, major 是感兴趣的主编号, name 是驱动的名子(出现在 /proc/devices), fops 是缺省的 file_operations 结构. 一个对 register_chrdev 的调用为给定的主编号, 并且为每一个建立一个缺省的 cdev 结构. 如果你使用 	register_chrdev, 从系统中去除你的设备的正确的函数是:
	
	int unregister_chrdev(unsigned int major, const char *name);
	
major 和 name 必须和传递给 register_chrdev 的相同, 否则调用会失败.

当前已经注册使用的设备可以通过 一个典型的 /proc/devices 文件得到:

	Character devices:
	 1 mem
	 2 pty
	 3 ttyp
	 4 ttyS
	 6 lp
	 7 vcs
	 10 misc
	 13 input
	 14 sound 
	 21 sg
	 180 usb
	
	Block devices:
	 2 fd
	 8 sd
	 11 sr
	 65 sd
	 66 sd 

### 设备编号的内部表示
在内核中, dev_t 类型(在 linux/types.h 中定义)用来持有设备编号 -- 主次部分都包括. 对于 2.6.0 内核, dev_t 是 32 位的量, 12 位用作主编号, 20 位用作次编号. 你的代码应当, 当然, 对于设备编号的内部组织从不做任何假设; 相反, 应当利用在 linux/kdev_t.h 中的一套宏定义. 为获得一个 dev_t 的主或者次编号, 使用:

	MAJOR(dev_t dev); 
	MINOR(dev_t dev);
	
相反, 如果你有主次编号, 需要将其转换为一个 dev_t, 使用:

	MKDEV(int major, int minor); 

注意, 2.6 内核能容纳有大量设备, 而以前的内核版本限制在 255 个主编号和 255 个次编号. 有人认为这么宽的范围在很长时间内是足够的, 但是计算领域被这个特性的错误假设搞乱了. 因此你应当希望 dev_t 的格式将来可能再次改变; 但是, 如果你仔细编写你的驱动, 这些变化不会是一个问题.


[上一节](chp103-1.html)  |  [目录索引](../index.html)  |  [下一节](chp103-3.html)
