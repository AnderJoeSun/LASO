---
layout: post
title: 源码开放学ARM - Linux 中断处理 - 中断处理程序
---

## 中断处理程序

### Linux 注册函数

前面部分讲了irq_desc 的初始化，初始化是为了设备驱动的使用。
设备驱动还要将设备处理回掉函数注册到irq_desc的表项中。这就是我们要讲的request_irq。
 声明在 linux/interrupt.h :
 
	int request_irq(unsigned int irq,
			irqreturn_t (*handler)(int, void *, struct pt_regs *),
			unsigned long flags,

			const char *dev_name,
			void *dev_id);

	void free_irq(unsigned int irq, void *dev_id);

从 request_irq 返回给请求函数的返回值或者是 0 指示成功, 或者是一个负的错误码, 如同平常. 
函数返回 -EBUSY 来指示另一个驱动已经使用请求的中断线是不寻常的. 

函数的参数如下:

	unsigned int irq 		// 请求的中断号

	irqreturn_t (*handler) 		// 安装的处理函数指针. 我们在本章后面讨论给这个函数的参数以及它的返回值.
	
	unsigned long flags 		// 与中断管理相关的选项的位掩码(后面描述).

	const char *dev_name 		//这个传递给 request_irq 的字串用在 /proc/interrupts 来显示中断的拥有者(下一节看到)

	void *dev_id 			// 用作共享中断线的指针. 它是一个独特的标识, 用在当释放中断线时以及可能还被驱动用来指向它自己的私有数据区(来标识哪个设备在中断). 如果中断没有被共享, dev_id 可以设置为 NULL, 但是使用这个项指向设备结构不管如何是个好主意. 我们将在"实现一个处理"一节中看到 dev_id 的一个实际应用.

flags 中可以设置的位如下:

	SA_INTERRUPT 
		当置位了, 这表示一个"快速"中断处理. 快速处理在当前处理器上禁止中断来执行(这个主题在"快速和慢速处理"一节涉及).
	SA_SHIRQ 
		这个位表示中断可以在设备间共享. 共享的概念在"中断共享"一节中略述.
	SA_SAMPLE_RANDOM 
		这个位表示产生的中断能够有贡献给 /dev/random 和 /dev/urandom 使用的加密池. 这些设备在读取时返回真正的随机数并且设计来帮助应用程序软件为加密选择安全钥. 这样的随机数从一个由各种随机事件贡献的加密池中提取的. 如果你的设备以真正随机的时间产生中断, 你应当设置这个标志. 如果, 另一方面, 你的中断是可预测的( 例如, 一个帧抓取器的场消隐), 这个标志不值得设置 -- 它无论如何不会对系统加密有贡献. 可能被攻击者影响的设备不应当设置这个标志; 例如, 网络驱动易遭受从外部计时的可预测报文并且不应当对加密池有贡献. 更多信息看 drivers/char/random.c 的注释. 

	设备通过函数request_irq（）注册一个IRQ号，并提供相应的处理函数。
 
 下面是键盘驱动程中注册中断的代码：

	request_irq(IRQ_EINT0, key1_irq_isr, SA_INTERRUPT, "key2345irq", NULL);
 
IRQ_EINT0是IRQ号, key1_irq_isr（）是处理函数。如果该函数成功的话，irq_desc[IRQ_EINT0]的action成员将会指向一个新分配的irqaction结构，该结构的handler指向key1_irq_isr（）。 

### /proc 接口

无论何时一个硬件中断到达处理器, 一个内部的计数器递增, 提供了一个方法来检查设备是否如希望地工作. 报告的中断显示在 /proc/interrupts. 下面的快照取自一个双处理器 Pentium 系统:

	root@montalcino:/bike/corbet/write/ldd3/src/short# cat /proc/interrupts
		CPU0     CPU1 
	 0:  4848108       34   IO-APIC-edge  timer 
	 2:        0        0         XT-PIC  cascade 
	 8:        3        1   IO-APIC-edge  rtc 
	 10:    4335        1  IO-APIC-level  aic7xxx 
	 11:    8903        0  IO-APIC-level  uhci_hcd 
	 12:      49        1   IO-APIC-edge  i8042  
	NMI:       0        0  
	LOC: 4848187  4848186  
	ERR:       0  
	MIS:       0  

第一项是中断的号，第二项是中断的次数，第三项是中断的触发方式，第四项是中断名称。

### 中断的处理过程

#### 中断信号由外部设备发送到中断控制器，中断控制器根据IRQ号转换成相应的中断向量号传给CPU 。

#### CPU接收中断后，保存现场，根据中断向量号到IDT中查找相应的处理函数。对于IRQ n的中断，它的处理函数IRQn_interrutp()。

#### 调用do_IRQ()函数。该函数完成对中断控制器确认、设置中断源状态等动作，接着它会根据IRQ号找到描述中断具体动作的irqaction结构变量action，执行如下代码：

	do {
	    status |= action->flags;
	    action->handler(irq,action->dev_id,regs); /*调用设备的处理函数*/
	      action = action->next;
	   } while (action);
	   
   while循环是用来处理设备共享中断号的情况。
#### 最后do_IRQ()函数要检查是否有软中断，如有则调用do_softirq()执行软中断。

#### 跳转到 ret_from_intr退出，恢复中断前的现场。 

### Tasklet
	
	#include <linux/module.h>	// module_init
	#include <asm/io.h>		// ioremap
	#include <linux/fs.h>		// file_operations
	#include <asm/uaccess.h>	// copy_from_user
	#include <linux/sched.h>	// wait_queue 
	
	#include <mach/gpio.h>		// S5PV210_GPH2
	#include <mach/regs-gpio.h>
	#include <linux/interrupt.h>	// requst_irq
	#include <linux/irq.h>		// IRQ_TYPE_EDGE_BOTH
	#include <asm/thread_info.h>		// IRQ_TYPE_EDGE_BOTH
	
	
	MODULE_LICENSE("GPL");
	
	struct tasklet_struct mytasklet;
	
	void do_sth(unsigned long data);
	
	irqreturn_t btn_irq_handler(int irq, void * dev_id)
	{
		int local = 100;
	
		printk("<irq> irq = %d \n", irq);	
		
		printk("<irq> &dev = %p \n", &dev_id);	
		printk("<irq> &irq = %p \n", &irq);	
		printk("<irq> &local = %p \n", &local);	
	
		printk("current = %p \n", current);	
		printk("current = %s \n", current->comm);	
		printk("current pid = %d \n", current->pid);	
	
		tasklet_schedule(&mytasklet);
		tasklet_schedule(&mytasklet);
	//	do_sth(100);
	
		printk("<irq> = %d \n", irq);	
	
		return IRQ_HANDLED;
	}
	
	void do_sth(unsigned long data)
	{
		volatile int i;
		int local = 100;
	
		printk("\tbegin do_sth...\n");
	
		printk("\t<do> &data = %p \n", &data);	
		printk("\t<do> &i = %p \n", &i );	
		printk("\t<do_sth> &local = %p \n", &local);	
	
		printk("\t<do> current = %p \n", current);	
		printk("\t<do> current = %s \n", current->comm);	
		printk("\t<do> current pid = %d \n", current->pid);	
	
		for (i = 0; i < 1000000000; i++)
			;
	
		printk("\tend do_sth...\n");
	
		return;
	}
	
	static int btn_drv_init(void)
	{
		int err;
		unsigned long data = 100;
	
		int * p = ((int)&data) & 0xFFFFE000;
	
		struct thread_info * pt = (struct thread_info *)p;
	
		printk("btn init \n");
	
		printk("\t<do> &data = %p \n", &data);	
		printk("p = %p\n", p);
	
		printk("pt -> current = %p\n", pt->task);
	
		printk("\t<do> current = %p \n", current);	
	
	
		tasklet_init(&mytasklet, do_sth, data);
	
		// see include/linux/irq.h for more types
		//err = request_irq(irq, btn_irq_handler, IRQ_TYPE_EDGE_BOTH,
		err = request_irq(160, btn_irq_handler, IRQ_TYPE_EDGE_FALLING,
				"btn0", NULL);
		if (err)
		{
			printk("request irq 0 failed!\n");
		}
	
		err = request_irq(161, btn_irq_handler, IRQ_TYPE_EDGE_FALLING,
				"btn1", NULL);
		if (err)
		{
			printk("request irq 1 failed!\n");
		}
	
	
		printk("request irq ok! err = %d\n", err);
	
		return 0;
	}
	
	static void btn_drv_exit(void)
	{
		printk("btn exit \n");
	
		free_irq(160, NULL);
		free_irq(161, NULL);
	
		return;
	}
	
	module_init(btn_drv_init);
	module_exit(btn_drv_exit);

	
### Examples	
	#include <linux/module.h>
	#include <linux/kernel.h>
	#include <linux/interrupt.h>
	#include <linux/irqreturn.h>
	//#include <linux/irq.h>
	
	MODULE_LICENSE("GPL");
	
	#define DPRINT(x)	printk("<%s> " #x " = 0x%x\n", __func__, (int)x);
	
	irqreturn_t myhandler(int irq, void * p)
	{
	//	printk("irqmyhandler called!\n");
		DPRINT(irq);
	
		return IRQ_HANDLED;	
	}
	
	static __init int interrupt_init(void)
	{
		int ri;
		int btn_irq;
	
		DPRINT(interrupt_init);
		
		btn_irq = 160;
	
	//	ri = request_irq(17, myhandler, 0, "my test interrupt", NULL);
	//	ri = request_irq(17, 1, 0, "my test interrupt", NULL);
		ri = request_irq(btn_irq, myhandler, IRQF_TRIGGER_FALLING, "btn K1 interrupt", NULL);
		ri = request_irq(btn_irq+1, myhandler, IRQF_TRIGGER_FALLING, "btn K2 interrupt", NULL);
	
		DPRINT(ri);
	
		return 0;
	}
	
	static __exit void interrupt_exit(void)
	{
		DPRINT(interrupt_exit);
	
		free_irq(160, NULL);
		free_irq(161, NULL);
	
		return;
	}
	
	module_init(interrupt_init);
	module_exit(interrupt_exit);

实际使用过程中，中断的信号常常是用来作为唤醒等待队列里面睡眠的进程的，这就需要了解有关等待队列的知识。




[上一节](chp104-2.html)  |  [目录索引](../index.html)  |  [下一节](chp104-4.html)
