---
layout: post
title: 源码开放学ARM - Linux 驱动开发基础 - 开发调试流程
---

## 开发调试流程

### 基本流程

#### 编译应用程序
<http://github.com/limingth/ARM-Lessons/blob/master/CortexA8-s5pv210-20120901/tiny210/examples/leds/led.c>

<http://github.com/limingth/ARM-Lessons/blob/master/CortexA8-s5pv210-20120901/tiny210/examples/buttons/buttons_test.c>

<http://github.com/limingth/ARM-Lessons/blob/master/CortexA8-s5pv210-20120901/tiny210/examples/pwm/pwm_test.c>

	$ make led
	$ make buttons_test
	$ make pwm_test

#### 编译设备驱动
	/* mini210_leds.c */
	#include <linux/kernel.h>
	#include <linux/module.h>
	#include <linux/miscdevice.h>
	#include <linux/fs.h>
	#include <linux/types.h>
	#include <linux/moduleparam.h>
	#include <linux/slab.h>
	#include <linux/ioctl.h>
	#include <linux/cdev.h>
	#include <linux/delay.h>
	
	#include <mach/gpio.h>
	#include <mach/regs-gpio.h>
	#include <plat/gpio-cfg.h>
	
	
	#define DEVICE_NAME "leds"
	
	static int led_gpios[] = {
		S5PV210_GPJ2(0),
		S5PV210_GPJ2(1),
		S5PV210_GPJ2(2),
		S5PV210_GPJ2(3),
	};
	
	#define LED_NUM		ARRAY_SIZE(led_gpios)
	
	
	static long mini210_leds_ioctl(struct file *filp, unsigned int cmd,
			unsigned long arg)
	{
		switch(cmd) {
			case 0:
			case 1:
				if (arg > LED_NUM) {
					return -EINVAL;
				}
	
				gpio_set_value(led_gpios[arg], !cmd);
				//printk(DEVICE_NAME": %d %d\n", arg, cmd);
				break;
	
			default:
				return -EINVAL;
		}
	
		return 0;
	}
	
	static struct file_operations mini210_led_dev_fops = {
		.owner			= THIS_MODULE,
		.unlocked_ioctl	= mini210_leds_ioctl,
	};
	
	static struct miscdevice mini210_led_dev = {
		.minor			= MISC_DYNAMIC_MINOR,
		.name			= DEVICE_NAME,
		.fops			= &mini210_led_dev_fops,
	};
	
	static int __init mini210_led_dev_init(void) {
		int ret;
		int i;
	
		for (i = 0; i < LED_NUM; i++) {
			ret = gpio_request(led_gpios[i], "LED");
			if (ret) {
				printk("%s: request GPIO %d for LED failed, ret = %d\n", DEVICE_NAME,
						led_gpios[i], ret);
				return ret;
			}
	
			s3c_gpio_cfgpin(led_gpios[i], S3C_GPIO_OUTPUT);
			gpio_set_value(led_gpios[i], 1);
		}
	
		ret = misc_register(&mini210_led_dev);
	
		printk(DEVICE_NAME"\tinitialized\n");
	
		return ret;
	}
	
	static void __exit mini210_led_dev_exit(void) {
		int i;
	
		for (i = 0; i < LED_NUM; i++) {
			gpio_free(led_gpios[i]);
		}
	
		misc_deregister(&mini210_led_dev);
	}
	
	module_init(mini210_led_dev_init);
	module_exit(mini210_led_dev_exit);
	
	MODULE_LICENSE("GPL");
	MODULE_AUTHOR("FriendlyARM Inc.");


#### 下载至开发板上
	ftp.sh	网络传输
	rx 串口传送

#### 加载驱动
	insmod led.ko
	printk 输出调试信息
	
#### 测试应用
	调用 ioctl 点亮 led 灯
	./led
	
	编译 buttons_test.c ，运行按键测试程序
	./buttons_test
	
	编译 pwm_test.c ，运行蜂鸣器测试程序
	./pwm_test
	
#### 编译驱动内核模块
	$ tar zxvf linux-2.6.35.7-20120829.tar.gz
	$ cd linux-2.6.35.7/
	$ ls
		Process: kernel/arch 
		Memery: mm/
		File: fs/
		Device: drivers/
		Net: net/

	$ make menuconfig
	$ make

### 课堂小练习
	完成一个 跑马灯 的应用程序。读取用户按键编号 n，作为启动 跑马灯 之后的循环次数。
	要求每次按键按下时，蜂鸣器播放一个对应频率的按键音，循环结束后，蜂鸣器播放一个结束音。
	
	
	 
[上一节](chp101-3.html)  |  [目录索引](../index.html)  |  [下一节](chp102-1.html)
