---
layout: post
title: 源码开放学ARM - Linux 中断处理 - 等待队列
---

## 等待队列

### 声明和调用接口
在 Linux 中, 一个等待队列由一个"等待队列头"来管理, 一个 wait_queue_head_t 类型的结构, 定义在 linux/wait.h 中. 
一个等待队列头可被定义和初始化, 使用:

	DECLARE_WAIT_QUEUE_HEAD(name); 
	
或者动态地, 如下:

	wait_queue_head_t my_queue;
	init_waitqueue_head(&my_queue);
	
当一个进程睡眠, 它这样做以期望某些条件在以后会成真. 如我们之前注意到的, 任何睡眠的进程必须在它再次
醒来时检查来确保它在等待的条件真正为真. 
Linux 内核中睡眠的最简单方式是一个宏定义, 称为 wait_event(有几个变体); 
它结合了处理睡眠的细节和进程在等待的条件的检查. 

wait_event 的形式是:

	wait_event(queue, condition)
	wait_event_interruptible(queue, condition)	

基本的唤醒睡眠进程的函数称为 wake_up. 它有几个形式(但是我们现在只看其中 2 个):

	void wake_up(wait_queue_head_t *queue);
	void wake_up_interruptible(wait_queue_head_t *queue);

wake_up 唤醒所有的在给定队列上等待的进程(尽管这个情形比那个要复杂一些, 如同我们之后将见到的). 其他
的形式(wake_up_interruptible)限制它自己到处理一个可中断的睡眠. 通常, 这 2 个是不用区分的(如果你使用可
中断的睡眠); 

### 范例代码 

实际上, 惯例是使用 wake_up 如果你在使用 wait_event , wake_up_interruptible 如果你在使用 wait_event_interruptible.

实现一个有简单行为的设备:任何试图从这个设备读取的进程都被置为睡眠. 无论何时一个进程写这个设备, 
所有的睡眠进程被唤醒. 这个行为由下面的 read 和 write 方法实现:

	static DECLARE_WAIT_QUEUE_HEAD(wq);
	static int flag = 0;
	ssize_t sleepy_read (struct file *filp, char __user *buf, size_t count, loff_t *pos)
	{
	        printk(KERN_DEBUG "process %i (%s) going to sleep\n",
	               current->pid, current->comm);
	        wait_event_interruptible(wq, flag != 0);
	        flag = 0;
	        printk(KERN_DEBUG "awoken %i (%s)\n", current->pid, current->comm);
	        return 0; /* EOF */
	}
	ssize_t sleepy_write (struct file *filp, const char __user *buf, size_t count, loff_t *pos)
	{
	        printk(KERN_DEBUG "process %i (%s) awakening the readers...\n",
	               current->pid, current->comm);
	        flag = 1;
	        wake_up_interruptible(&wq);
	        return count; /* succeed, to avoid retrial */
	}
	
注意这个例子里 flag 变量的使用. 因为 wait_event_interruptible 检查一个必须变为真的条件, 我们使用 flag 来创建
那个条件.	


## 内核定时器

	#include <linux/init.h>
	#include <linux/module.h>
	#include <asm/current.h> 
	#include <linux/sched.h>
	
	MODULE_LICENSE("GPL");

	extern struct task_struct * current;
	
	struct timer_list mytimer;
	
	void timer_handler(unsigned long arg)
	{
		printk("timer arg = %d\n", arg);
	
		return;
	}
	
	static int __init akae_init(void)
	{
		int local = 0;
		printk("module name is %s\n", KBUILD_MODNAME);
		printk("akae_init at %p\n", akae_init);
		printk("local at %p\n", &local);
		printk("jiffies at %p\n", &jiffies);
		printk("jiffies is %ld\n", jiffies);
		printk("The process is \"%s\" (pid %i)\n", current->comm, current->pid);
	
		init_timer(&mytimer);
	
		printk("HZ = %d\n", HZ);
		mytimer.expires = jiffies + HZ * 5;
		mytimer.function = timer_handler;
		mytimer.data = 100;
	
		add_timer(&mytimer);
	
		printk("timer ok!\n");
	
		return 0;
	}
	
	static void __exit akae_exit(void)
	{
		printk("module liming exit\n");
		printk("akae_exit at %p\n", akae_exit);
	
		del_timer_sync(&mytimer);
	
		return;
	}
	
	module_init(akae_init);
	module_exit(akae_exit);
[上一节](chp104-3.html)  |  [目录索引](../index.html)  |  [下一节](chp105-1.html)
