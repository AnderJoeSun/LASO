---
layout: post
title: 源码开放学ARM - Linux 驱动的并发控制 - 信号量
---

## 信号量

### 信号量的操作
定义在 linux/semaphore.h 中，实现在 ipc/sem.c 和 kernel/semaphore.c 中

	1、定义信号量
	struct semaphore sem;
	
	2、初始化一个信号量
	void sema_init(struct semaphore *sem,int val);
	初始化该信号sem，并把它的值设为val。
	void init_MUTEX(struct semaphore *sem);
	初始化一个信号量，并把信号量的值设为1。
	void init_MUTEX_LOCKED(struct semaphore);
	初始化一个信号量，并把该值设为0。
	
	3、定义并初始化的快捷方式
	DECLARE_MUTEX(name)；
	DECLARE_MUTEX_LOCKED(name)；
	
	4、获得信号量
	void down(struct semaphore *sem);
	用于获得信号量，他会导致睡眠，所以不能在中断上下文中使用，进入睡眠后不能用信号打断。
	int down_interruptible(struct semaphore *sem);
	进入睡眠后可被信号中断，此时返回值为非0，一般如果得到非0的值就立即返回-ERESTARTSYS；
	int down_trylock(struct semaphore *sem);
	尝试获得信号量sem，如果能够立刻获得该信号量就获得该信号量，并返回0，否则返回非0，它不会导致调用者睡眠，可以在中断上下文中使用。
	
	5、释放信号量
	void up(struct semaphore *sem)
	
	6、信号量使用方法：
	DECLARE_MUTEX(mount_sem);
	down(&mount_sem);
	……//临界区
	up(&mount_sem);

###  信号量的衍生（略）

#### 读写信号量
读写信号量与信号量的关系和读写自旋锁与自旋锁的关系类似，读写信号量可能引起进程阻塞，但它可以允许多个读执行单元同时访问共享资源，而最多只有一个写执行单元。


[上一节](chp105-4.html)  |  [目录索引](../index.html)  |  [下一节](chp105-6.html)
